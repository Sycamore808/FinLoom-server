# FinLoom 用户认证系统说明

## 📋 概述

FinLoom平台已经集成了完整的用户认证和数据隔离系统，支持：
- ✅ 用户注册和登录
- ✅ 安全的密码加密存储（PBKDF2-HMAC-SHA256）
- ✅ Token-based身份验证
- ✅ 用户会话管理
- ✅ 用户数据隔离
- ✅ 用户活动日志

## 🗄️ 数据库结构

### 用户表 (users)
- `user_id`: 用户ID（主键）
- `username`: 用户名（唯一）
- `email`: 邮箱（唯一，可选）
- `password_hash`: 密码哈希
- `salt`: 盐值
- `display_name`: 显示名称
- `avatar_url`: 头像URL
- `created_at`: 创建时间
- `updated_at`: 更新时间
- `last_login`: 最后登录时间
- `is_active`: 是否激活
- `is_admin`: 是否为管理员

### 用户会话表 (user_sessions)
- `session_id`: 会话ID（主键）
- `user_id`: 用户ID（外键）
- `token`: 访问令牌（唯一）
- `created_at`: 创建时间
- `expires_at`: 过期时间
- `last_activity`: 最后活动时间
- `ip_address`: IP地址
- `user_agent`: 用户代理
- `is_valid`: 是否有效

### 用户设置表 (user_settings)
- `setting_id`: 设置ID（主键）
- `user_id`: 用户ID（外键）
- `setting_key`: 设置键
- `setting_value`: 设置值
- `updated_at`: 更新时间

### 用户活动日志表 (user_activity_log)
- `log_id`: 日志ID（主键）
- `user_id`: 用户ID（外键）
- `activity_type`: 活动类型
- `activity_detail`: 活动详情
- `ip_address`: IP地址
- `timestamp`: 时间戳

## 🔌 后端API端点

### 1. 用户注册
**POST** `/api/auth/register`

请求体：
```json
{
  "username": "user123",
  "password": "password123",
  "email": "user@example.com",
  "display_name": "用户名称"
}
```

响应：
```json
{
  "status": "success",
  "message": "注册成功",
  "data": {
    "user_id": 1,
    "username": "user123"
  }
}
```

### 2. 用户登录
**POST** `/api/auth/login`

请求体：
```json
{
  "username": "user123",
  "password": "password123",
  "remember": true
}
```

响应：
```json
{
  "status": "success",
  "message": "登录成功",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "user": {
      "user_id": 1,
      "username": "user123",
      "email": "user@example.com",
      "display_name": "用户名称",
      "avatar_url": null,
      "is_admin": false
    }
  }
}
```

### 3. 验证Token
**GET** `/api/auth/verify`

请求头：
```
Authorization: Bearer {token}
```

响应：
```json
{
  "status": "success",
  "message": "令牌有效",
  "valid": true,
  "user": {
    "user_id": 1,
    "username": "user123",
    ...
  }
}
```

### 4. 获取用户资料
**GET** `/api/auth/profile`

请求头：
```
Authorization: Bearer {token}
```

响应：
```json
{
  "status": "success",
  "data": {
    "user_id": 1,
    "username": "user123",
    "email": "user@example.com",
    "display_name": "用户名称",
    "avatar_url": null,
    "created_at": "2024-01-01T00:00:00",
    "last_login": "2024-01-01T12:00:00",
    "is_admin": false
  }
}
```

### 5. 更新用户资料
**PUT** `/api/auth/profile`

请求头：
```
Authorization: Bearer {token}
```

请求体：
```json
{
  "display_name": "新的显示名称",
  "email": "newemail@example.com",
  "avatar_url": "https://example.com/avatar.jpg"
}
```

### 6. 修改密码
**POST** `/api/auth/change-password`

请求头：
```
Authorization: Bearer {token}
```

请求体：
```json
{
  "old_password": "oldpassword123",
  "new_password": "newpassword123"
}
```

### 7. 用户登出
**POST** `/api/auth/logout`

请求头：
```
Authorization: Bearer {token}
```

## 🖥️ 前端使用

### 在前端代码中使用认证API

```javascript
import { api } from '@/services'

// 用户注册
const registerResponse = await api.auth.register({
  username: 'user123',
  password: 'password123',
  email: 'user@example.com'
})

// 用户登录
const loginResponse = await api.auth.login({
  username: 'user123',
  password: 'password123',
  remember: true
})

// 保存token
localStorage.setItem('finloom_token', loginResponse.data.data.token)

// 验证token
const verifyResponse = await api.auth.verify()

// 获取用户资料
const profileResponse = await api.auth.getProfile()

// 更新用户资料
const updateResponse = await api.auth.updateProfile({
  display_name: '新名称',
  email: 'new@example.com'
})

// 修改密码
const passwordResponse = await api.auth.changePassword({
  old_password: 'old123',
  new_password: 'new123'
})

// 登出
const logoutResponse = await api.auth.logout()
```

### 在组件中获取当前用户

```javascript
import { ref, onMounted } from 'vue'
import { api } from '@/services'

const currentUser = ref(null)

onMounted(async () => {
  try {
    const response = await api.auth.getProfile()
    if (response.data.status === 'success') {
      currentUser.value = response.data.data
    }
  } catch (error) {
    console.error('获取用户信息失败:', error)
  }
})
```

## 🔧 后端集成用户上下文

### 在FastAPI路由中使用用户认证

```python
from fastapi import Depends
from common.user_context import get_current_user, UserContext

@app.get("/api/my-endpoint")
async def my_endpoint(user: UserContext = Depends(get_current_user)):
    """需要用户认证的端点"""
    user_id = user.user_id
    username = user.username
    is_admin = user.is_admin
    
    # 使用用户信息进行业务逻辑处理
    ...
```

### 使用装饰器方式

```python
from common.user_context import require_auth, require_admin

@app.get("/api/protected")
@require_auth
async def protected_endpoint(user: UserContext):
    """需要用户认证"""
    return {"message": f"你好, {user.username}"}

@app.get("/api/admin-only")
@require_admin
async def admin_endpoint(user: UserContext):
    """仅管理员可访问"""
    return {"message": "管理员专用功能"}
```

### 用户数据隔离

```python
from common.user_context import UserDataManager

# 为用户添加数据过滤
manager = UserDataManager()

# 方式1：在SQL查询中添加用户过滤
query_params = {"limit": 10}
query_params = manager.add_user_filter(query_params, user.user_id)
# 结果: {"limit": 10, "user_id": 1}

# 方式2：验证用户对资源的所有权
record_user_id = get_record_user_id_from_db(record_id)
manager.require_ownership(record_user_id, user.user_id, user.is_admin)
# 如果不是所有者且不是管理员，会抛出403异常

# 方式3：获取用户专属表名
table_name = manager.get_user_specific_table_name("conversations", user.user_id)
# 结果: "conversations_user_1"
```

## 📝 修改现有模块以支持用户隔离

### 示例：修改对话历史API

修改前（无用户隔离）：
```python
@app.get("/api/v1/chat/conversations")
async def get_conversations():
    # 获取所有对话（所有用户共享）
    conversations = get_all_conversations()
    return conversations
```

修改后（有用户隔离）：
```python
from fastapi import Depends
from common.user_context import get_current_user, UserContext

@app.get("/api/v1/chat/conversations")
async def get_conversations(user: UserContext = Depends(get_current_user)):
    # 只获取当前用户的对话
    conversations = get_user_conversations(user.user_id)
    return conversations
```

### 示例：修改数据库查询

修改前：
```python
def get_all_strategies():
    cursor.execute("SELECT * FROM strategies")
    return cursor.fetchall()
```

修改后：
```python
def get_user_strategies(user_id: int):
    cursor.execute(
        "SELECT * FROM strategies WHERE user_id = ?",
        (user_id,)
    )
    return cursor.fetchall()
```

## 🧪 测试

### 运行自动测试
```bash
python test_user_auth.py
```

测试脚本会自动测试：
1. ✅ 用户注册
2. ✅ 用户登录
3. ✅ Token验证
4. ✅ 获取用户资料
5. ✅ 更新用户资料
6. ✅ 拒绝错误密码
7. ✅ 拒绝无效Token
8. ✅ 用户登出

### 手动测试登录页面
1. 启动服务器：`python main.py`
2. 访问：`http://localhost:8000/login`
3. 点击"立即注册"创建新账户
4. 使用新账户登录

## 🔐 安全特性

1. **密码加密**：使用PBKDF2-HMAC-SHA256算法，100,000次迭代
2. **盐值**：每个用户使用独立的随机盐值
3. **Token安全**：48字节URL安全随机token
4. **会话管理**：支持过期时间和自动失效
5. **活动日志**：记录所有用户活动
6. **SQL注入防护**：使用参数化查询
7. **密码强度**：最少6个字符
8. **用户名验证**：最少3个字符

## 📊 用户数据隔离

所有用户相关的数据表都应该包含`user_id`字段，以确保数据隔离：

```sql
-- 示例：对话历史表
CREATE TABLE conversations (
    id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,  -- 用户ID
    title TEXT,
    created_at TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users (user_id)
)

-- 查询时必须加上用户过滤
SELECT * FROM conversations WHERE user_id = ?
```

## 🔄 迁移现有数据

如果已有数据需要添加用户隔离：

```sql
-- 1. 为现有表添加user_id列
ALTER TABLE existing_table ADD COLUMN user_id INTEGER;

-- 2. 为现有数据分配默认用户（例如管理员用户ID=1）
UPDATE existing_table SET user_id = 1 WHERE user_id IS NULL;

-- 3. 添加外键约束
-- SQLite不支持添加外键，需要重建表

-- 4. 创建索引以提高查询性能
CREATE INDEX idx_user_id ON existing_table(user_id);
```

## 🎯 下一步工作

1. ✅ 基础用户认证系统
2. ✅ 前端登录页面集成
3. ⏳ 为所有现有模块添加用户隔离
4. ⏳ 用户权限管理系统
5. ⏳ 多租户支持
6. ⏳ 第三方登录集成（OAuth）

## 📞 支持

如有问题，请查看：
- 日志文件：`logs/main.log`
- 用户数据库：`data/users.db`
- 测试脚本：`test_user_auth.py`


